<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RespiraWorks Ventilator: Cycle Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RespiraWorks Ventilator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cycle <a class="el" href="classController.html">Controller</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Our cycle controller runs on an STM32 ARM chip and is written in C++17.</p>
<p>For more details on the inner workings of the controller, see <a href="https://docs.google.com/document/d/1hztIBu9DR52r0LQuIpt6DZByBLfXfJy21BGqk2F34g8">Controller description</a>.</p>
<p><b>TODO:</b> Migrate contents of the above document to github.</p>
<p>There is a <a href="https://docs.google.com/spreadsheets/d/1JOSQKxkQxXJ6MCMDI9PwUQ6kiuGdujR4D6EJN9u2LWg/edit#gid=0">Circuit board ICD</a> which is a good reference on controller peripherals.</p>
<h2><a class="anchor" id="autotoc_md347"></a>
Why C++?</h2>
<p>C is a much more common programming language in the embedded space, so our choice of C++ deserves some discussion.</p>
<p>Simply put, we chose C++ over C because we believe it is a more productive programming language. Here are some advantages we’ve found to using C++.</p>
<ul>
<li>In C we’d have to represent a pressure measurement as a number, e.g. a float. This is <a href="https://mars.nasa.gov/msp98/news/mco990930.html">error-prone</a> in part because the compiler can’t help you keep your units consistent. In contrast, our C++ code represents a pressure measurement using an explicit <a href="../common/libs/units/units.h">Pressure</a> type. You can create a <a class="el" href="classPressure.html">Pressure</a> from a measurement in kPa or cmH2O and the software will do the unit conversions automatically. We also support operators between types. For instance, dividing a <a class="el" href="classVolume.html">Volume</a> by a <a class="el" href="classDuration.html">Duration</a> yields an object of type <a class="el" href="classVolumetricFlow.html">VolumetricFlow</a>, again with the units automatically correct. This is a zero-cost abstraction &ndash; it runs just as fast as the equivalent C code &ndash; and it eliminates whole classes of bugs.\</li>
<li>We use pieces of the C++17 standard library to add safety to our code. For instance, we use C++’s std::variant class for discriminated unions instead of C’s union construct. We also use std::optional throughout the code to represent a value that may not be present. This is much safer than most C solutions (e.g. using a sentinel value like -1 or NaN to mean "not present").</li>
<li>Some language features of C++ are inherently safer than the respective features of plain C. For example, C++ requires the programmer to be explicit about type conversion in cases where the conversion may be lossy (e.g. from a floating-point to an integer type, or from an integer type to a more narrow integer type). In contrast, C allows such conversions implicitly, failing to protect against a common source of errors in safety-critical software.</li>
</ul>
<p>We have configured our environment to disallow dynamic memory allocation, and we do not use C++ exceptions.</p>
<h2><a class="anchor" id="autotoc_md348"></a>
Software Provenance</h2>
<p>We wrote all of the cycle controller software from scratch, with two exceptions:</p>
<ul>
<li>We use <a href="https://github.com/nanopb/nanopb">nanopb</a> for protocol buffer encoding/decoding. Nanopb is an extensively tested library used in many projects, and protocol buffers are an industry standard for data exchange.</li>
<li>Our <a class="el" href="classPID.html">PID</a> controller is based on an <a href="https://github.com/br3ttb/Arduino-PID-Library/">Arduino library</a>, although our version has evolved beyond the point of recognition &ndash; every line of code has been rewritten and our version is several times smaller by line count. It has fewer features, and we have added extensive unit tests.</li>
</ul>
<p>Notably, all of our code for interacting with the STM32 hardware is bespoke; we are not using the Arduino STM32 hardware abstraction layer or any other third-party HAL. This ensures auditability over every line of code in this critical part of the system.</p>
<h2><a class="anchor" id="autotoc_md349"></a>
Software Design</h2>
<p>The cycle controller follows a modular design, described below.</p>
<p><img src="https://g.gravizo.com/source/cc_graph_mark?https%3A%2F%2Fraw.githubusercontent.com%2FRespiraWorks%2FVentilator%2Fmaster%2Fsoftware%2Fdesign%2Fcontroller_architecture.md" alt="Graph of components in cycle controller" class="inline"/></p>
<p>The main loop runs every 10ms and has the following responsibilities:</p>
<ul>
<li>Reset the watchdog timer. If the watchdog timer is not reset within 250ms, the microcontroller assumes it is stuck and restarts.</li>
<li>Instruct comms to send a packet to GUI if necessary, and check whether comms has received a packet from the GUI.</li>
<li>Instruct controller to recalculate desired actuator positions, based on the commands in the latest packet received from the GUI.</li>
</ul>
<p>Comms communicates with the GUI app running on the Raspberry Pi. Recall that the communication protocol is simply that the controller periodically sends all its state to the GUI, and the GUI periodically sends all of its state to the controller, overwriting any previous state. The protocol is defined <a href="../common/generated_libs/network_protocol/network_protocol.proto">here</a>.</p>
<p>On each iteration of the main loop, the controller component forwards the parameters from the GUI (e.g. PEEP 5, PIP 20, …) to the breath FSM (finite state machine, see below), which responds with a "desired
system state", the physical properties we want the pneumatic system to have at this moment. Since we have implemented pressure-controlled ventilation modes, the main physical property to achieve is patient pressure. The controller reads from the sensors, uses <a class="el" href="classPID.html">PID</a> to calculate the valve positions and fan power which it thinks will achieve the desired state, and forwards these to the actuator.</p>
<p>The breath FSM (finite state machine) translates ventilator parameters into a timeseries of desired states of the ventilator’s pneumatic system. For example, the ventilator parameters "command pressure mode
with PEEP 5, PIP 20, RR 12 bpm, I:E 0.25" translates to the timeseries "start pressure at 5 cmH2O, linearly ramping up to 20 cmH2O over 100ms;
sit at 20 cmH2O for 900ms; then drop to 5 cmH2O for 4s".</p>
<p>The breath FSM is also responsible for inspiratory effort detection in pressure assist mode. In this case, the time series would keep pressure at PEEP until either a breath is detected or it has been too long between breaths.</p>
<p>The sensors module reads raw sensor voltages from HAL (hardware abstraction layer, see below) and translates them into physical measurements. It is responsible for calibrating the system’s three DP sensors and translating the readings into two flow measurements (one for each venturi) and one patient pressure measurement.</p>
<p>The actuators module receives a set of commands from the controller for every actuator in the system, e.g. "blower speed 90%, inspiratory pinch
valve 28% open, etc.", and forwards them down to HAL to be acted upon.</p>
<p>The actuators module might seem like an unnecessary component &ndash; why can’t the controller simply call into HAL itself? There are two reasons.</p>
<ul>
<li>Separating the choice of actuation state from actual actuation lets us unit test the controller.</li>
<li>When we run in simulation with Modelica for software-in-the-loop testing, we replace the real actuators component with a component that sends the commands to Modelica.</li>
</ul>
<p>Finally, our HAL (hardware abstraction layer) is responsible for communicating directly with the hardware, e.g. reading a voltage from the STM32’s analog-to-digital converter. The HAL also sends commands to the stepper drivers that control the ventilator’s pinch valves.</p>
<p>One last component which does not fit in the diagram or description above is the debug module. Among other things, this powerful module lets us read and write values in the controller without reflashing the device. We have used it to tune <a class="el" href="classPID.html">PID</a> in a live system, to operate the ventilator without the GUI attached (e.g. for automated testing), and to capture and graph the ventilator’s internal state as it runs.</p>
<h2><a class="anchor" id="autotoc_md350"></a>
Algorithms of note</h2>
<p>This section describes some significant algorithms implemented in the cycle controller.</p>
<h3><a class="anchor" id="autotoc_md351"></a>
Valve control</h3>
<p>The controller translates a desired patient pressure into inspiratory/expiratory valve positions using closed-loop <a class="el" href="classPID.html">PID</a> control. The PID’s integral term is set based on the PEEP-to-PIP pressure delta (i.e. some minor gain scheduling). The expiratory valve tracks the inspiratory valve; as the inspiratory valve opens more, the expiratory valve closes more.</p>
<h3><a class="anchor" id="autotoc_md352"></a>
Venturi pressure to flow conversion</h3>
<p>We characterized the response of our venturis over a large range of flows using a Fleisch pneumotachograph. We used a standard venturi pressure-to-flow formula with a correction factor of 0.97 as the only correction applied. The comparison between the two instruments matched our empirical measurements very closely. The 0.97 correction factor is in line with ISO recommendations for smooth surfaces with a Reynolds number of104.</p>
<h3><a class="anchor" id="autotoc_md353"></a>
Volume zeroing</h3>
<p>The net volume change over a breath is not always exactly 0, due to leakage, sensor zero-point drift, and the fact that venturis have relatively high error at low flows. A simple way to correct for this would be to set volume at the beginning of every breath to 0, but this introduces a discontinuity in the graph at each breath, which looks wrong. And fundamentally it does not solve the problem; one can still observe that volume measurements are "sloped".</p>
<p>Our volume zeroing algorithm addresses this. At the start of each breath, we predict what the volume would be at the next breath if the flow error remained constant. We then apply a flow offset to drive the next breath’s volume to 0.</p>
<p>This works well on test lungs, but more work is required to characterize its behavior in more realistic situations, like coughing, airway blockage, etc. We also need to understand better users’ expectations about how flow leakage should show up in the ventilator’s graphs. We expect we will need a more sophisticated algorithm.</p>
<p>We track volume by integrating flow over time. Getting an accurate flow measurement is challenging with our current hardware, especially at low flow rates, where the venturi's SNR is worst.</p>
<p>We currently use a "big hammer" to address this, essentially forcing volume to 0 at each breath boundary. This may hide leaks and other clinically-relevant data from users, and so this algorithm likely needs to be improved in the future, potentially in combination with different or additional sensors.</p>
<h3><a class="anchor" id="autotoc_md354"></a>
Inspiratory effort detection</h3>
<p>We use the following algorithm to detect inspiratory effort in pressure support mode. First, we wait for flow to become nonnegative during the exhale phase. Then we start keeping two <a href="https://en.wikipedia.org/wiki/Moving_average%23Exponential_moving_average">exponentially-weighted moving averages</a> of flow. The "slow average" has a small alpha term and thus reacts slowly to changes in flow. The "fast average" has a large alpha term and thus reacts quickly. We can think of the slow average as characterizing "normal flow" during the expiratory cycle (which we’ve observed on test lungs does change, but slowly), while the fast average calculates "current flow". When the fast average exceeds the slow average by a certain threshold, that triggers a breath.</p>
<p>This works well on our test lungs, but much more testing is needed to see how it performs in more realistic situations. Graphs and a demo video are available in <a href="https://docs.google.com/document/d/1g7qLD5qD4BKfR1mcGq7-QY6XE2C9oIIw5GJdUzU31Zg/edit?ts%3D5eefc588%23heading%3Dh.pt7ef8fp4ywf">02-1 Performance Evaluation</a>.</p>
<h2><a class="anchor" id="autotoc_md355"></a>
Status of Oxygen Flow Control</h2>
<p>Our ventilator can currently deliver 100% oxygen (supplied by an external source of pressurized oxygen) or ambient air (supplied via our blower fan), but cannot currently mix these two gasses.</p>
<p>Variable FiO2 requires a more complicated control scheme, controlling both the air proportional valve and the oxygen proportional solenoid together. We are currently exploring two controller schemes for achieving this. We've tried both of these in the modelica model, though neither has been tried on hardware yet.</p>
<p>The first controller scheme is to ratio-control the two valves. In this scheme, a single <a class="el" href="classPID.html">PID</a> commands both the air valve and the oxygen valve simultaneously to achieve the desired pressure targets in the different breathe stages. The mapping from the <a class="el" href="classPID.html">PID</a> command to the actual valve command is determined by a ratio that is adjusted across breathe cycles by a separate <a class="el" href="classPID.html">PID</a> controller designed to achieve the desired FiO2.</p>
<p>The challenge with this scheme is that the current valves (the oxygen proportional solenoid and the air proportional pinch valve) have extremely different response times, which may make it difficult to achieve stable control.</p>
<p>An alternative scheme is to use one of the valves to control pressure and the other valve to control FiO2. The valve that is controlling pressure would be controlled by a <a class="el" href="classPID.html">PID</a> during the inhale and exhale phases. The valve that is controlling FiO2 would have a constant value across inhale and a constant value across exhale - these values would then be adjusted by the FiO2 <a class="el" href="classPID.html">PID</a> across breaths. For this scheme, if the FiO2 were below about 70-80%, then the air valve would be used to control pressure and the oxygen valve would be used to manage FiO2; for higher FiO2, this would be reversed.</p>
<p>The benefit of this approach is that it avoids trying to control both valves simultaneously. The downside of this approach is that it can lead to greater FiO2 variability over a breath, has a greater risk of pressure over/undershoot, and, for stability reasons, will likely necessitate a slower rate of FiO2 change. Based on discussions with doctors, achieving the necessary FiO2 within 30-60s was deemed acceptable, meaning that a safer control scheme that minimizes over/undershoot risk by adjusting FiO2 more slowly may be acceptable. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
